+++
title = "é«˜æ€§èƒ½æœåŠ¡å™¨"
date = "2024-05-08T16:10:36+08:00"

#
# description is optional
#
# description = "An optional description for SEO. If not provided, an automatically created summary will be used."

tags = ["é«˜æ€§èƒ½æœåŠ¡å™¨","æ€§èƒ½åˆ†æ",]
+++

# é«˜æ€§èƒ½æœåŠ¡å™¨åˆ†æ

---
å£°æ˜ï¼šä¸€ç‚¹ç‚¹è‡ªå·±çš„æ€»ç»“ä¸æ„Ÿæ‚Ÿå§ï¼Œå¦‚æœæœ‰ä¸å¯¹çš„åœ°æ–¹ï¼Œçƒ¦è¯·æŒ‡æ­£

> æœåŠ¡å™¨æœ€é‡è¦çš„æ˜¯èƒ½å¤Ÿè§£å†³å¤æ‚çš„ç½‘ç»œé—®é¢˜ï¼Œå¤§é‡å¹¶å‘è¯·æ±‚ï¼Œå¦‚ç»å…¸çš„**c10K** ï¼Œå½“ç„¶åé¢è¿™ä¸ªå¹¶å‘é—®é¢˜å»¶ä¼¸åˆ°**c10M**
>> å½“ç„¶è¿™ä¸ª c10k å·²ç»è¢«ä»ç¡¬ä»¶å’Œè½¯ä»¶ä¸¤ä¸ªæ–¹é¢è§£å†³äº†ï¼Œç¡¬ä»¶æ–¹é¢åº”è¯¥æ˜¯åœ¨ æ‘©å°”å®šå¾‹ä¸Šä¸‹åŠŸå¤«ï¼Ÿ è½¯ä»¶æ–¹é¢å°±æœ‰å¾ˆå¤šæ–¹å‘äº†ï¼Œç„¶åæ¥ä¸‹æ¥ç€é‡è®²è½¯ä»¶æ–¹é¢çš„è§£å†³æ–¹æ¡ˆ

## OS & question

> æœ‰äººè¯´ï¼Œæ“ä½œç³»ç»Ÿçš„åº•å±‚è®¾è®¡è®©é€šä¿¡å¼€é”€å¢å¤§
>
>> åŸè¯æ˜¯ï¼Œos çš„å†…æ ¸ä¸æ˜¯è§£å†³c10Mé—®é¢˜çš„åŠæ³•ï¼Œç›¸åos çš„å†…æ ¸æ­£æ˜¯å¯¼è‡´C10Mé—®é¢˜çš„å…³é”®
>
>> ç®€å•è§£é‡Šä¸€ä¸‹ï¼Œæ¯”å¦‚ç½‘ç»œåŒ…è¿›å…¥ç½‘å¡ï¼Œç„¶åé€šè¿‡ç½‘å¡è¿›å…¥å†…æ ¸å¤„ç†ï¼Œå†…æ ¸æ¥ç€æ‹·è´æŠŠæ•°æ®è½¬ç»™ç”¨æˆ·ç¨‹åºå¤„ç†ï¼Œå†æŠŠå¤„ç†çš„æ•°æ®é€šè¿‡ç½‘å¡å‘é€å®¢æˆ·ç«¯

å¤§è‡´çš„æ€è·¯æ˜¯è¿™æ ·ï¼Œç„¶åå°±æœ‰äººåœ¨è¿™é‡Œåˆ†æï¼Œåˆ†æçš„ç»“è®ºæœ‰ä»¥ä¸‹å‡ ä¸ªæ–¹é¢

- ä¸­æ–­å¤„ç†ï¼Œé¢‘ç¹çš„ç¡¬ä»¶ä¸­æ–­è¯·æ±‚ä¼šå¢åŠ osèµ„æºçš„å¼€é”€ï¼Œå°¤å…¶æ˜¯ç¡¬ä»¶ä¸­æ–­ä¼šæ‰“æ–­ä½çº§çš„è½¯ä¸­æ–­æˆ–è€…ç³»ç»Ÿè°ƒç”¨çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œè¿™ç§æ‰“æ–­ä¼šå¢åŠ ä¸€å®šçš„æ€§èƒ½å¼€é”€
- å†…å­˜æ‹·è´ï¼Œæ•°æ®åŒ…ä»ç½‘å¡åˆ°å†…æ ¸å¼€è¾Ÿçš„ç¼“å†²åŒºï¼Œå†ç”±å†…æ ¸ç¼“å†²åŒºåˆ°ç”¨æˆ·æ€ç©ºé—´ï¼Œåœ¨linux å†…æ ¸åè®®æ ˆæ±‡ä¸­çš„è€—æ—¶å åˆ°äº†æ•´ä¸ªæ•°æ®åŒ…å¤„ç†è¿‡ç¨‹çš„57.1%
- ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œé¢‘ç¹çš„ä¸­æ–­å¤„ç†ï¼Œä¼šäº§ç”Ÿå¤§é‡çš„ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼Œè€Œä¸”å¯èƒ½æ¶‰åŠèµ„æºç«äº‰ï¼Œè¿™å°±ä¼šæ¶‰åŠé”çš„å¤„ç†ï¼Œç”¨**é”**ä¹Ÿæ˜¯ä¸€ä¸ªå¾ˆå¤§å¼€é”€
- å±€éƒ¨æ€§å¤±æ•ˆï¼Œåœ¨å¤šæ ¸å¤„ç†å™¨ä¸­ï¼Œä¸€ä¸ªæ•°æ®åŒ…è·¨å¤šä¸ªcpuæ ¸å¿ƒï¼Œå¦‚æ•°æ®åŒ…ä¸­æ–­åœ¨cpu0ï¼Œå†…æ ¸å¤„ç†åœ¨cpu1ï¼Œç”¨æˆ·æ€å¤„ç†åœ¨cpu2ï¼Œè¿™æ ·è·¨å¤šæ ¸ï¼Œå®¹æ˜“å¢åŠ cpuç¼“å­˜å¤±æ•ˆï¼Œé€ æˆå±€éƒ¨æ€§å¤±æ•ˆ
- å†…å­˜ç®¡ç†ï¼ŒæœåŠ¡å™¨å†…å­˜é¡µ4k ï¼Ÿç„¶åä¸ºäº†æé«˜å†…å­˜çš„è®¿é—®é€Ÿåº¦ï¼Œé¿å…cache miss ï¼Œå¢åŠ cache çš„æ˜ å°„è¡¨æ¡ç›®ï¼Œ**ä½†æ˜¯è¿™å¢åŠ äº†cpu æ£€ç´¢æ•ˆç‡**

å½“ç„¶ä¹Ÿæœ‰è§£å†³æ–¹æ¡ˆ

- æ§åˆ¶å±‚å’Œæ•°æ®å±‚åˆ†å±‚
- å¤šæ ¸æŠ€æœ¯
- NUMA äº²å’Œæ€§
- å¤§é¡µå­˜æŠ€æœ¯
- æ— é”æŠ€æœ¯

## è§£å†³æ¡ˆä¾‹

æ˜¯çš„ï¼Œæœ‰ä¸€äº›åŒ…å«ä¸Šè¿°çš„è§£å†³æ–¹æ¡ˆçš„ç½‘ç»œæ¡†æ¶ï¼ˆğŸ¤¦ï¼‰å¥½åƒæœ‰å¾ˆå¤šå¾ˆå¤šç½‘ç»œæ¡†æ¶ï¼Œéƒ½è¯´è‡ªå·±è´¼ç‰›é€¼ï¼ˆé«˜å¯ç”¨ã€åˆ†å¸ƒå¼ã€é«˜æ€§èƒ½

å…·ä½“åˆ°çš„æœ‰ï¼Œ6windã€Windriverã€Netmapã€DPDK

è¿™ä¸ªDPDK å…¶å®å¥½åƒå¾ˆç«ï¼Œåé¢å¯ä»¥æœ‰ç©ºç ”ç©¶ä¸€ä¸‹

## å¿ƒå¾—

å¥½åƒï¼Œè‡ªå·±å†™è¿‡çš„é¡¹ç›®ï¼Œé«˜æ€§èƒ½æ˜¯è¿™æ ·èµ°çš„ï¼Œ

### é¦–å…ˆæ˜¯å¯¹æ•°æ®çš„å¤„ç†ï¼Œä½¿ç”¨å„ç§æ± 
>çº¿ç¨‹æ± ï¼ˆThread Poolï¼‰
>>çº¿ç¨‹æ± æ˜¯é¢„å…ˆåˆ›å»ºä¸€ç»„çº¿ç¨‹ï¼Œä»»åŠ¡æäº¤åå°†åˆ†é…ç»™ç©ºé—²çš„çº¿ç¨‹å¤„ç†ã€‚çº¿ç¨‹æ± ç”¨äºé¿å…çº¿ç¨‹é¢‘ç¹åˆ›å»ºå’Œé”€æ¯çš„å¼€é”€ï¼Œæé«˜å¹¶å‘æ€§èƒ½ã€‚
>
>æ•°æ®åº“è¿æ¥æ± ï¼ˆConnection Poolï¼‰
>>æ•°æ®åº“è¿æ¥æ± ç®¡ç†æ•°æ®åº“è¿æ¥ã€‚å®ƒé¢„å…ˆåˆ›å»ºä¸€ç»„æ•°æ®åº“è¿æ¥ï¼Œå¹¶åœ¨éœ€è¦æ—¶åˆ†é…ã€‚è¿™æ ·å¯ä»¥å‡å°‘æ¯æ¬¡è¿æ¥æ•°æ®åº“çš„å¼€é”€ï¼Œæé«˜æ•°æ®åº“æ“ä½œçš„æ€§èƒ½ã€‚
>
>å¯¹è±¡æ± ï¼ˆObject Poolï¼‰
>>å¯¹è±¡æ± ç”¨äºç®¡ç†å¯é‡å¤ä½¿ç”¨çš„å¯¹è±¡ï¼Œé¿å…å¯¹è±¡çš„é¢‘ç¹åˆ›å»ºå’Œé”€æ¯ã€‚å¯¹è±¡æ± å¯ä»¥ç”¨åœ¨å„ç§åœºæ™¯ï¼Œå¦‚æ¸¸æˆå¼€å‘ä¸­çš„æ¸¸æˆå¯¹è±¡ã€æ•°æ®åº“è¿æ¥ã€ç½‘ç»œèµ„æºç­‰ã€‚
>
>ç¼“å­˜æ± ï¼ˆCache Poolï¼‰
>>ç¼“å­˜æ± ç”¨äºç®¡ç†ç¼“å­˜ï¼Œæä¾›å¿«é€Ÿè®¿é—®æ•°æ®çš„èƒ½åŠ›ã€‚ç¼“å­˜æ± é€šå¸¸ç”¨äºæé«˜ç³»ç»Ÿæ€§èƒ½å’Œå“åº”é€Ÿåº¦ï¼Œå‡å°‘æ•°æ®åº“æˆ–å…¶ä»–åç«¯ç³»ç»Ÿçš„è´Ÿè½½ã€‚
>
>çº¿ç¨‹æœ¬åœ°æ± ï¼ˆThread Local Poolï¼‰
>>çº¿ç¨‹æœ¬åœ°æ± ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºä¸€ç»„ç‹¬ç«‹çš„èµ„æºï¼Œç¡®ä¿æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„èµ„æºæ± ã€‚è¿™åœ¨éœ€è¦é¿å…çº¿ç¨‹é—´èµ„æºå…±äº«çš„æƒ…å†µä¸‹éå¸¸æœ‰ç”¨ã€‚
>
>å†…å­˜æ± ï¼ˆMemory Poolï¼‰
>>å†…å­˜æ± ç”¨äºç®¡ç†å†…å­˜å—ã€‚é€šè¿‡é¢„å…ˆåˆ†é…ä¸€å—å¤§å†…å­˜ï¼Œç„¶åä»ä¸­åˆ’åˆ†å°å—ï¼Œå‡å°‘å†…å­˜åˆ†é…å’Œé‡Šæ”¾çš„å¼€é”€ã€‚è¿™ç§æŠ€æœ¯åœ¨éœ€è¦é¢‘ç¹åˆ†é…å’Œé‡Šæ”¾å†…å­˜çš„åº”ç”¨ä¸­éå¸¸æœ‰ç”¨ã€‚
>
>è¿æ¥æ± ï¼ˆConnection Poolï¼‰
>>è¿æ¥æ± å¯ä»¥ç”¨äºç½‘ç»œè¿æ¥ç®¡ç†ã€‚å®ƒç±»ä¼¼äºæ•°æ®åº“è¿æ¥æ± ï¼Œä½†ç”¨äºç®¡ç†ç½‘ç»œè¿æ¥ï¼Œå¦‚ä¸æœåŠ¡å™¨ã€å¤–éƒ¨æœåŠ¡ç­‰çš„è¿æ¥ã€‚
>
>èµ„æºæ± ï¼ˆResource Poolï¼‰
>>èµ„æºæ± å¯ä»¥ç®¡ç†å„ç§ç±»å‹çš„èµ„æºï¼Œå¦‚çº¿ç¨‹ã€å¯¹è±¡ã€è¿æ¥ç­‰ã€‚èµ„æºæ± çš„ç›®çš„æ˜¯æé«˜èµ„æºåˆ©ç”¨ç‡ï¼Œå‡å°‘èµ„æºåˆ›å»ºå’Œé”€æ¯çš„å¼€é”€ã€‚
>
>æ¶ˆæ¯æ± ï¼ˆMessage Poolï¼‰
>>æ¶ˆæ¯æ± ç”¨äºç®¡ç†æ¶ˆæ¯å¯¹è±¡ï¼Œé€šå¸¸ç”¨äºæ¶ˆæ¯é˜Ÿåˆ—ã€äº‹ä»¶ç³»ç»Ÿç­‰ã€‚æ¶ˆæ¯æ± å¯ä»¥å‡å°‘æ¶ˆæ¯å¯¹è±¡çš„åˆ›å»ºå’Œé”€æ¯ï¼Œæé«˜æ¶ˆæ¯å¤„ç†çš„æ€§èƒ½ã€‚
>

### ç„¶åæ˜¯ioå¤šè·¯å¤ç”¨

#### æ¯”å¦‚å¸¸è§çš„â€œä¸‰å‰‘å®¢â€ selectã€pollã€epoll

(ç¯å¢ƒlinux c/c++)

- select

```c++
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <iostream>
#include <cstring>

int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in address = {0};
    address.sin_family = AF_INET;
    address.sin_port = htons(8080);
    address.sin_addr.s_addr = INADDR_ANY;

    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 3);

    fd_set readfds;
    while (true) {
        FD_ZERO(&readfds);
        FD_SET(server_fd, &readfds);
        int max_fd = server_fd;

        int activity = select(max_fd + 1, &readfds, nullptr, nullptr, nullptr);
        if (activity < 0 && errno != EINTR) {
            std::cerr << "Select error" << std::endl;
            break;
        }

        if (FD_ISSET(server_fd, &readfds)) {
            int client_fd = accept(server_fd, nullptr, nullptr);
            const char *message = "Hello from select server\n";
            send(client_fd, message, strlen(message), 0);
            close(client_fd);
        }
    }

    close(server_fd);
    return 0;
}
```


- poll

```c++
#include <sys/poll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <iostream>
#include <cstring>

int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in address = {0};
    address.sin_family = AF_INET;
    address.sin_port = htons(8080);
    address.sin_addr.s_addr = INADDR_ANY;

    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 3);

    pollfd fds[1];
    fds[0].fd = server_fd;
    fds[0].events = POLLIN;

    while (true) {
        int activity = poll(fds, 1, -1);
        if (activity < 0) {
            std::cerr << "Poll error" << std::endl;
            break;
        }

        if (fds[0].revents & POLLIN) {
            int client_fd = accept(server_fd, nullptr, nullptr);
            const char *message = "Hello from poll server\n";
            send(client_fd, message, strlen(message), 0);
            close(client_fd);
        }
    }

    close(server_fd);
    return 0;
}

```

- epoll

```c++
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <iostream>
#include <cstring>

int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in address = {0};
    address.sin_family = AF_INET;
    address.sin_port = htons(8080);
    address.sin_addr.s_addr = INADDR_ANY;

    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 3);

    int epoll_fd = epoll_create(1);
    epoll_event event = {0};
    event.events = EPOLLIN;
    event.data.fd = server_fd;
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &event);

    while (true) {
        epoll_event events[10];
        int activity = epoll_wait(epoll_fd, events, 10, -1);
        if (activity < 0) {
            std::cerr << "Epoll error" << std::endl;
            break;
        }

        for (int i = 0; i < activity; i++) {
            if (events[i].data.fd == server_fd) {
                int client_fd = accept(server_fd, nullptr, nullptr);
                const char *message = "Hello from epoll server\n";
                send(client_fd, message, strlen(message), 0);
                close(client_fd);
            }
        }
    }

    close(server_fd);
    return 0;
}
```







### pr & create ?

(è¿™å—æˆ‘æš‚æ—¶æƒ³ä¸äº†ï¼Œç³»ç»Ÿçš„å†™ä¸€ç¯‡åšå®¢çœŸçš„è¦ç‚¹ä¸œè¥¿å•Š)

## è¾¹ç¼˜è§¦å‘ && æ°´å¹³è§¦å‘

> è¾¹ç¼˜è§¦å‘ edge  trigger ï¼ˆETï¼‰
> æ°´å¹³è§¦å‘ level trigger

[æºç å‚è€ƒ](https://github.com/Manistein/test_epoll_lt_and_et)

- server

```c++
//server
#include <stdlib.h>
#include <stdio.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <fcntl.h>
#include <errno.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>

static int do_listen(const char* host, int port) {
    struct addrinfo ai_hints;
    struct addrinfo* ai_list = NULL;
    char portstr[16];
    sprintf(portstr, "%d", port);
    memset(&ai_list, 0, sizeof(ai_hints));

    ai_hints.ai_socktype = SOCK_STREAM;
    ai_hints.ai_protocol = IPPROTO_TCP;

    int status = getaddrinfo(host, portstr, &ai_hints, &ai_list);
    if (status != 0) {
        return -1;
    }

    int fd = socket(ai_list->ai_family, ai_list->ai_socktype, 0);
    if (fd < 0) {
        freeaddrinfo(ai_list);
        return -1;
    }

    status = bind(fd, (struct sockaddr*)ai_list->ai_addr, ai_list->ai_addrlen);
    if (status != 0) {
        close(fd);
        freeaddrinfo(ai_list);
        return -1;
    }

    listen(fd, 30);

    printf("do_listen success fd:%d\n", fd);
    return fd;
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("please input mode, lt or et\n");
        return -1;
    }

    int ep_event = 0;
    if (strcmp(argv[1], "et") == 0) {
        ep_event = EPOLLET;
    }
    else if (strcmp(argv[1], "lt") == 0) {
        ep_event = 0;
    }
    else {
        printf("unknow mode %s please input lt or et\n", argv[1]);
        return -1;
    }


    int epfd = epoll_create(1024);
    if (epfd == -1) {
        printf("fail to create epoll %d\n", errno);
        return -1;
    }

    int listen_fd = do_listen("127.0.0.1", 8001);
    if (listen_fd < 0) {
        printf("do listen fail");
        return -1;
    }

    struct epoll_event ee;
    ee.events = EPOLLIN;
    ee.data.fd = listen_fd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &ee);

    for(;;) {
        printf("before epoll epoll_wait\n");
        struct epoll_event ev[16];
        int n = epoll_wait(epfd, ev, 16, -1);
        if (n == -1) {
            printf("epoll_wait error %d", errno);
            break;
        }

        printf("after epoll_wait event n:%d\n", n);

        for (int i = 0; i < n; i ++) {
            struct epoll_event* e = &ev[i];
            if (e->data.fd == listen_fd) {
                struct sockaddr s;
                socklen_t len = sizeof(s);
                int client_fd = accept(listen_fd, &s, &len);
                if (client_fd < 0) {
                    break;
                }

                fcntl(client_fd, F_SETFL, O_NONBLOCK);
                ee.events = EPOLLIN | ep_event;
                ee.data.fd = client_fd;
                epoll_ctl(epfd, EPOLL_CTL_ADD, client_fd, &ee);
                printf("accpet new connection fd:%d\n", client_fd);
            }
            else {
                int client_fd = e->data.fd;
                int flag = e->events;
                int r = (flag & EPOLLIN) != 0;
                if (r) {
                    printf("read fd:%d\n", client_fd);
                    char buffer[2] = {0};
                    int n = read(client_fd, buffer, 2);
                    printf("read number %d\n", n);
                    if (n < 0) {
                        switch(errno) {
                            case EINTR: break;
                            case EWOULDBLOCK: break;
                            default: break;
                        }
                    }
                    else if (n == 0) {
                        epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, NULL);
                        close(client_fd);
                        break;
                    }
                    else {
                        printf("----%c%c\n", buffer[0], buffer[1]);
                    }
                }
            }
        }
    }

    return 0;
}
```


- client

```c++
//client
#include <stdlib.h>
#include <stdio.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <fcntl.h>
#include <errno.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>

static int do_listen(const char* host, int port) {
    struct addrinfo ai_hints;
    struct addrinfo* ai_list = NULL;
    char portstr[16];
    sprintf(portstr, "%d", port);
    memset(&ai_list, 0, sizeof(ai_hints));

    ai_hints.ai_socktype = SOCK_STREAM;
    ai_hints.ai_protocol = IPPROTO_TCP;

    int status = getaddrinfo(host, portstr, &ai_hints, &ai_list);
    if (status != 0) {
        return -1;
    }

    int fd = socket(ai_list->ai_family, ai_list->ai_socktype, 0);
    if (fd < 0) {
        freeaddrinfo(ai_list);
        return -1;
    }

    status = bind(fd, (struct sockaddr*)ai_list->ai_addr, ai_list->ai_addrlen);
    if (status != 0) {
        close(fd);
        freeaddrinfo(ai_list);
        return -1;
    }

    listen(fd, 30);

    printf("do_listen success fd:%d\n", fd);
    return fd;
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("please input mode, lt or et\n");
        return -1;
    }

    int ep_event = 0;
    if (strcmp(argv[1], "et") == 0) {
        ep_event = EPOLLET;
    }
    else if (strcmp(argv[1], "lt") == 0) {
        ep_event = 0;
    }
    else {
        printf("unknow mode %s please input lt or et\n", argv[1]);
        return -1;
    }


    int epfd = epoll_create(1024);
    if (epfd == -1) {
        printf("fail to create epoll %d\n", errno);
        return -1;
    }

    int listen_fd = do_listen("127.0.0.1", 8001);
    if (listen_fd < 0) {
        printf("do listen fail");
        return -1;
    }

    struct epoll_event ee;
    ee.events = EPOLLIN;
    ee.data.fd = listen_fd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &ee);

    for(;;) {
        printf("before epoll epoll_wait\n");
        struct epoll_event ev[16];
        int n = epoll_wait(epfd, ev, 16, -1);
        if (n == -1) {
            printf("epoll_wait error %d", errno);
            break;
        }

        printf("after epoll_wait event n:%d\n", n);

        for (int i = 0; i < n; i ++) {
            struct epoll_event* e = &ev[i];
            if (e->data.fd == listen_fd) {
                struct sockaddr s;
                socklen_t len = sizeof(s);
                int client_fd = accept(listen_fd, &s, &len);
                if (client_fd < 0) {
                    break;
                }

                fcntl(client_fd, F_SETFL, O_NONBLOCK);
                ee.events = EPOLLIN | ep_event;
                ee.data.fd = client_fd;
                epoll_ctl(epfd, EPOLL_CTL_ADD, client_fd, &ee);
                printf("accpet new connection fd:%d\n", client_fd);
            }
            else {
                int client_fd = e->data.fd;
                int flag = e->events;
                int r = (flag & EPOLLIN) != 0;
                if (r) {
                    printf("read fd:%d\n", client_fd);
                    char buffer[2] = {0};
                    int n = read(client_fd, buffer, 2);
                    printf("read number %d\n", n);
                    if (n < 0) {
                        switch(errno) {
                            case EINTR: break;
                            case EWOULDBLOCK: break;
                            default: break;
                        }
                    }
                    else if (n == 0) {
                        epoll_ctl(epfd, EPOLL_CTL_DEL, client_fd, NULL);
                        close(client_fd);
                        break;
                    }
                    else {
                        printf("----%c%c\n", buffer[0], buffer[1]);
                    }
                }
            }
        }
    }

    return 0;
}
```

---

## é˜»å¡ä¸éé˜»å¡

é˜»å¡ I/O
åœ¨é˜»å¡æ¨¡å¼ä¸‹ï¼Œå½“ä¸€ä¸ª I/O æ“ä½œï¼ˆä¾‹å¦‚è¯»å–æ•°æ®ã€å†™å…¥æ•°æ®ï¼‰è¢«è°ƒç”¨æ—¶ï¼Œå¦‚æœæ•°æ®ä¸å¯ç”¨æˆ–æ“ä½œæ— æ³•ç«‹å³å®Œæˆï¼Œç¨‹åºä¼šç­‰å¾…ï¼Œç›´åˆ°æ“ä½œå®Œæˆã€‚è¿™æ„å‘³ç€ç¨‹åºçš„æ‰§è¡Œå°†æš‚åœï¼Œç›´åˆ° I/O æ“ä½œå®Œæˆã€‚

ç‰¹ç‚¹
ç®€å•æ˜“ç”¨ï¼šé˜»å¡ I/O é€šå¸¸æ›´ç®€å•ï¼Œç¼–ç¨‹æ›´å®¹æ˜“ç†è§£ã€‚ç¨‹åºåªéœ€ç­‰å¾…æ“ä½œå®Œæˆï¼Œæ— éœ€å¤„ç†å¼‚æ­¥æ“ä½œã€‚
å¯èƒ½å¯¼è‡´æ€§èƒ½ç“¶é¢ˆï¼šé˜»å¡ I/O ä¼šå¯¼è‡´æ•´ä¸ªçº¿ç¨‹æš‚åœï¼Œè¿™åœ¨å¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚æ—¶å¯èƒ½å¯¼è‡´æ€§èƒ½ç“¶é¢ˆã€‚
é€‚ç”¨äºç®€å•åº”ç”¨ï¼šå¯¹äºä¸éœ€è¦é«˜å¹¶å‘çš„åº”ç”¨ï¼Œé˜»å¡ I/O æ˜¯ä¸€ç§ç®€å•æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚
é€‚ç”¨åœºæ™¯
å•çº¿ç¨‹åº”ç”¨ï¼šåœ¨å•çº¿ç¨‹ç¯å¢ƒä¸­ï¼Œé˜»å¡ I/O å¯èƒ½æ›´å®¹æ˜“å®ç°ï¼Œå› ä¸ºæ²¡æœ‰å¹¶å‘é—®é¢˜ã€‚
ä½å¹¶å‘åº”ç”¨ï¼šåœ¨ä¸éœ€è¦å¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚çš„æƒ…å†µä¸‹ï¼Œé˜»å¡ I/O å¯ä»¥ç®€åŒ–ç¼–ç¨‹ã€‚
æ‰¹å¤„ç†ä»»åŠ¡ï¼šåœ¨ä¸éœ€è¦å³æ—¶å“åº”çš„æ‰¹å¤„ç†ä»»åŠ¡ä¸­ï¼Œé˜»å¡ I/O å¯èƒ½æ˜¯åˆé€‚çš„é€‰æ‹©ã€‚
éé˜»å¡ I/O
åœ¨éé˜»å¡æ¨¡å¼ä¸‹ï¼ŒI/O æ“ä½œç«‹å³è¿”å›ï¼Œè€Œä¸ç­‰å¾…æ“ä½œå®Œæˆã€‚å¦‚æœæ“ä½œæ— æ³•ç«‹å³å®Œæˆï¼Œç¨‹åºä¼šå¾—åˆ°ä¸€ä¸ªæ ‡å¿—ï¼ˆå¦‚ EAGAIN æˆ– EWOULDBLOCKï¼‰ï¼ŒæŒ‡ç¤ºç¨åå†å°è¯•ã€‚éé˜»å¡ I/O é€šå¸¸ä¸ I/O å¤šè·¯å¤ç”¨æŠ€æœ¯ï¼ˆå¦‚ selectã€pollã€epollï¼‰ç»“åˆä½¿ç”¨ã€‚

ç‰¹ç‚¹
é«˜å¹¶å‘ï¼šéé˜»å¡ I/O é€‚åˆå¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚ï¼Œå› ä¸ºçº¿ç¨‹ä¸ä¼šå› ä¸º I/O æ“ä½œè€Œé˜»å¡ã€‚
éœ€è¦å¼‚æ­¥å¤„ç†ï¼šéé˜»å¡ I/O é€šå¸¸éœ€è¦å¤„ç†å¼‚æ­¥æ“ä½œï¼Œå¯èƒ½å¢åŠ ä»£ç çš„å¤æ‚æ€§ã€‚
æ›´å¤æ‚çš„è®¾è®¡ï¼šéé˜»å¡ I/O éœ€è¦è€ƒè™‘å¹¶å‘å’ŒåŒæ­¥é—®é¢˜ï¼Œè®¾è®¡å¤æ‚åº¦æ›´é«˜ã€‚
é€‚ç”¨åœºæ™¯
é«˜å¹¶å‘æœåŠ¡å™¨ï¼šåœ¨å¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚æ—¶ï¼Œéé˜»å¡ I/O å¯ä»¥æé«˜æœåŠ¡å™¨çš„ååé‡å’Œæ€§èƒ½ã€‚
äº‹ä»¶é©±åŠ¨æ¶æ„ï¼šéé˜»å¡ I/O é€šå¸¸ä¸äº‹ä»¶é©±åŠ¨æ¶æ„ç»“åˆä½¿ç”¨ï¼Œå®ç°é«˜æ€§èƒ½æœåŠ¡å™¨ã€‚
å®æ—¶åº”ç”¨ï¼šåœ¨éœ€è¦å®æ—¶å“åº”çš„åº”ç”¨ä¸­ï¼Œéé˜»å¡ I/O å¯ä»¥æä¾›æ›´å¥½çš„æ€§èƒ½ã€‚
æ€»ç»“
é˜»å¡å’Œéé˜»å¡ I/O åœ¨æ€§èƒ½å’Œåº”ç”¨åœºæ™¯ä¸Šæœ‰æ˜¾è‘—åŒºåˆ«ã€‚é˜»å¡ I/O é€‚ç”¨äºç®€å•ã€ä½å¹¶å‘çš„åº”ç”¨ï¼Œè€Œéé˜»å¡ I/O é€‚ç”¨äºé«˜å¹¶å‘ã€äº‹ä»¶é©±åŠ¨çš„ç¯å¢ƒã€‚é€‰æ‹©å“ªç§æ¨¡å¼å–å†³äºåº”ç”¨çš„éœ€æ±‚ã€å¹¶å‘é‡å’Œæ€§èƒ½è¦æ±‚ã€‚

å¯¹äºé«˜æ€§èƒ½æœåŠ¡å™¨ï¼Œéé˜»å¡ I/O é€šå¸¸æ˜¯æ›´å¥½çš„é€‰æ‹©ï¼Œå› ä¸ºå®ƒå¯ä»¥å¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚ï¼Œæé«˜æœåŠ¡å™¨çš„æ€§èƒ½å’Œå¯æ‰©å±•æ€§ã€‚é˜»å¡ I/O æ›´é€‚åˆç®€å•ã€ä½å¹¶å‘çš„åº”ç”¨ã€‚é€‰æ‹©å“ªç§æ¨¡å¼è¦æ ¹æ®å…·ä½“åœºæ™¯å’Œéœ€æ±‚è€Œå®šã€‚

(é—®çš„gpt)


## æ€»ç»“

é«˜æ€§èƒ½æœåŠ¡å™¨ï¼Œé¦–å…ˆè¦å®Œæˆæœ€åŸºæœ¬çš„é€šä¿¡é—®é¢˜ï¼Œå…¶æ¬¡åœ¨è€ƒè™‘æ ¹æ®å„ç§å¤æ‚ç¯å¢ƒåšç›¸åº”çš„å¤„ç†ã€‚
ä¸å¦‚ï¼Œå¤šçº¿ç¨‹å°±ä¸é€‚åˆåšé˜»å¡
ä½†æ˜¯ï¼Œäº‹ä»¶å¤„ç†æœºåˆ¶å°±ä¸èƒ½ç”¨é˜»å¡è€Œè¦ç”¨éé˜»å¡

æœ‰å¾ˆå¤šæ—¶å€™ï¼Œä¼šæœ‰è¿™æ ·ä¸€ä¸ªideaï¼Œä¸€ä¸ªé—®é¢˜ï¼Œç«™åœ¨ä¸åŒè§’åº¦å»åˆ†æåˆæ˜¯å¦ä¸ªå‘³é“ï¼Œä¸‹æ¬¡å…·ä½“åŒ–è¯´æ¥å¬å¬ğŸ™Š
